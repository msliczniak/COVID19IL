#!/bin/sh

# This is a best guess at matching cases cause there is no ID and later files
# have correwctions like the age of the patient.

awk() {
	/usr/bin/awk "$@"
}

diff() {
	/usr/bin/diff "$@"
}

sed () {
	/usr/bin/sed "$@"
}

sort() {
	/usr/bin/sort "$@"
}

./ndeaths "$@"

# reverse order
set -- `printf '%s\n' ndeaths-*.txt | #
awk '{ a[++i] = $0 } END { while (i) print a[i--] }'`

# previous
p="$1"; shift

for i in "$@" /dev/null; do
	diff "$i" "$p" >deaths.txt
	case $? in
	  0 | 1)
		;;
	  *)
		exit
		;;
	esac

	# extra newline gives ndiff a place to sync
	sed -n 's/^> /\
/p' <deaths.txt >b || exit

	# ed command for easy syncing later
	awk '/^</ { printf("\n%s\n", substr($0, 3)); print c >"a.ed"; next }
	/^[->]/ { next }
	{ c = $0 }' deaths.txt >a

	time ./ndiff a b >deaths.txt || exit
	exit

	awk '{
	for (;;) {
		if ($0 == "+ " || $0 !~ /^\+ /) {
			if (!getline) break
			continue
		}

		l = substr($0, 3)
		if (!getline) {
			print l
			break
		}

		if ($0 ~ /^\? /) continue

		print l
	} }' deaths.txt >u"$i"

	p="$i"
done

awk 'BEGIN { date = "1970-01"; daten = -1 }

# days since epoch
function dse(d, f, c) {
	c = substr(d, 1, 7)
	if (c != date) {
		date = c

		f = "/bin/date -juf '\''%Y-%m-%d-%T'\''"
		f = sprintf("%s %s-01-00:00:00 '+%%s'", f, c)
		f | getline c
		close(f)

		daten = int(c / 86400) - 1
	}

	c = substr(d, 9, 2)
	return (c + daten)
}

FNR == 1 {
	# strip-off path
	d = match(FILENAME, "[^/]*$")
	d = substr(substr(FILENAME, d), 1)

	# get date
	if (d !~ /^[1-9][0-9][0-9][0-9]-/)
		d = substr(d, index(d, "-") + 1, 10)
	else
		d = substr(d, 1, 10)

	d = dse(d)
}

{
	printf("%4d ", d - $1)

	i = index($0, ",") + 1
	s = substr($0, i)
	if (s)
		printf("%2d", $1 - s)
	else
		printf(" -")

	printf(" %4s %s\n", $2, substr($0, 27, i - 28)) }' udeaths-*.txt | sort
