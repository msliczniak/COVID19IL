#!/bin/sh

# This is a best guess at matching cases cause there is no ID and later files
# have correwctions like the age of the patient.

awk() {
	/usr/bin/awk "$@"
}

diff() {
	/usr/bin/diff "$@"
}

sed () {
	/usr/bin/sed "$@"
}

sort() {
	/usr/bin/sort "$@"
}

tail() {
	/usr/bin/tail "$@"
}

# reverse order
set -- `./report "$@"`

# most recent
p="$1"; shift

for i in "$@"; do
	printf '%s\n' "$i" >&2

	diff -U0 "$i" "$p" | sed 's/^@@/\
/' | awk 'NR == 1 { cmd = "./ndiff -q a b"; next }
{
	# print uninversal diff command for this hunk
	print $1

	# create "from" file
	printf("") > "a"
	for (i = 2; i <= NF; i++) if ($i ~ /^-/) print substr($i, 2) > "a"
	fflush("a")
	close("a")

	# create "to" file
	printf("") > "b"
	for (i = 2; i <= NF; i++) if ($i ~ /^\+/) print substr($i, 2) > "b"
	fflush("b")
	close("b")

	# print ndiff of this hunk
	while (cmd | getline != 0) print
	close(cmd)
}' FS='\n' RS= #|
exit
 awk 'BEGIN { line = 1 }

/^ / {
	n = split($1, c, ",")
	lines = substr(c[1], 2) + 0
	print line, lines
	while (line++ < lines) {
		if (getline < f) {
			print
		}
	}

	if (n == 1) lines += 1
	else lines += c[2]
	while (line++ < lines) getline < f
	print lines

	next
}

$1 == "+" {
	to = substr($0, 3)

	if (!getline) lines = -1
	else if ($1 == "?") q = 1

	if (q) print to
	else print from

	if (lines == -1) exit
}

$1 == "-" {
	q = 0
	from = substr($0, 3)
}

$1 == "?" { q = 1 }

END { while (getline < f) print }' f="$i" #| sort
	exit
	
	
	
	
	awk 'NR < 3 { next }
{
	print "" > "a"
	for (i = 2; i <= NF; i++)
		if ($i ~ /^-/)
			print substr($i, 2) > "a"
	fflush("a")
	close("a")

	print "" > "b"
	for (i = 2; i <= NF; i++)
		if ($i ~ /^+/)
			print substr($i, 2) > "b"

	fflush("b")
	close("b")

	while ("./ndiff -q a b" | getline)
		print $0
}'
	exit

	# give ndiff a place to sync
	<report.txt sed -n \
's/^+/SYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNC\
/p' >b || exit

	# unified diff commands in file c for easy syncing later
	awk '/^-/ { printf("%s\n%s\n", s, substr($0, 2)); print c >"c"; next }
	/^@/ { c = $2 }' \
	s=SYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNCSYNC \
	report.txt >a

	exit

	./ndiff -q a b | awk '{
	for (;;) {
		if ($0 == "+ " || $0 !~ /^\+ /) {
			if (!getline) break
			continue
		}

		l = substr($0, 3)
		if (!getline) {
			print l
			break
		}

		if ($0 ~ /^\? /) continue

		print l
	} }' f="$i" | sort

	p="$i"
done
